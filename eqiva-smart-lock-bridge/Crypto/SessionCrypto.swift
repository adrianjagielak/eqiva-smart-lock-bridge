//
//  SessionCrypto.swift
//  eqiva-smart-lock-bridge
//
//  Created by Adrian Jagielak on 01/06/2025.
//

import Foundation
import CommonCrypto

/// Compute a 10-byte nonce: [messageTypeID (1B)] + sessionOpenNonce (8B) + [0x00, 0x00 (2B)] + securityCounter (2B)
func computeNonce(messageTypeID: UInt8, sessionOpenNonce: Data, securityCounter: UInt16) -> Data {
    var data = Data()
    data.append(messageTypeID)
    data.append(sessionOpenNonce)
    data.append(contentsOf: [0x00, 0x00])
    data.append(contentsOf: withUnsafeBytes(of: securityCounter.bigEndian) { Array($0) })
    return data
}

/// Encrypt or decrypt a Data array (arbitrary length) part of a secure message.
/// XOR against a keystream generated by AES-ECB(key, [0x01] + nonce + blockCounter).
func cryptData(_ data: Data, messageTypeID: UInt8, sessionOpenNonce: Data, securityCounter: UInt16, key: Data) -> Data {
    let nonce = computeNonce(messageTypeID: messageTypeID, sessionOpenNonce: sessionOpenNonce, securityCounter: securityCounter)
    let blockCount = Int(ceil(Double(data.count) / Double(kCCBlockSizeAES128)))
    var keystream = Data()

    for i in 0..<blockCount {
        let blockCounter = UInt16(i + 1).bigEndian
        var inputBlock = Data([0x01])
        inputBlock.append(nonce)
        inputBlock.append(contentsOf: withUnsafeBytes(of: blockCounter) { Array($0) })
        precondition(inputBlock.count == 1 + nonce.count + 2, "Invalid nonce construction")
        let keyStreamBlock = aes128EncryptBlock(inputBlock, key: key)
        keystream.append(keyStreamBlock)
    }

    return Data(zip(data, keystream).map { $0 ^ $1 })
}

/// Compute the 4-byte authentication value for a secure message.
/// Following the algorithm in keyble: AES-CMAC-like via ECB chaining.
func computeAuthenticationValue(data: Data, messageTypeID: UInt8, sessionOpenNonce: Data, securityCounter: UInt16, key: Data) -> Data {
    let nonce = computeNonce(messageTypeID: messageTypeID, sessionOpenNonce: sessionOpenNonce, securityCounter: securityCounter)
    let paddedData = data.padded(toMultipleOf: 16)
    let dataLengthBE = withUnsafeBytes(of: UInt16(data.count).bigEndian) { Data($0) }

    // Initial vector: [0x09] + nonce + dataLengthBE
    var iv = Data([0x09])
    iv.append(nonce)
    iv.append(dataLengthBE)
    precondition(iv.count == 1 + nonce.count + dataLengthBE.count)

    // Encrypt IV
    var encrypted = aes128EncryptBlock(iv, key: key)

    // Process each 16-byte block of paddedData
    for chunkStart in stride(from: 0, to: paddedData.count, by: 16) {
        let block = paddedData.subdata(in: chunkStart..<(chunkStart + 16))
        let xored = Data(zip(encrypted, block).map { $0 ^ $1 })
        encrypted = aes128EncryptBlock(xored, key: key)
    }

    // Calculate final: encrypted[0..<4] XOR AES-ECB([0x01] + nonce + [0x00,0x00], key)
    var iv2 = Data([0x01])
    iv2.append(nonce)
    iv2.append(contentsOf: [0x00, 0x00])
    let encrypted2 = aes128EncryptBlock(iv2, key: key)
    let authValue = Data(zip(encrypted.prefix(4), encrypted2).map { $0 ^ $1 })
    return authValue  // 4 bytes
}

